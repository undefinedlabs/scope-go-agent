package gocheck

import (
	"context"
	"math"
	"reflect"
	"testing"
	"time"

	"github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/log"

	"go.undefinedlabs.com/scopeagent/errors"
	"go.undefinedlabs.com/scopeagent/instrumentation"
	"go.undefinedlabs.com/scopeagent/instrumentation/coverage"
	"go.undefinedlabs.com/scopeagent/instrumentation/logging"
	"go.undefinedlabs.com/scopeagent/tags"

	chk "gopkg.in/check.v1"
)

type (
	Test struct {
		ctx    context.Context
		span   opentracing.Span
		method *methodType
		c      *chk.C
	}
)

// write cached result span
func writeCachedResult(method *methodType) {
	t := method.Info.Type.In(0)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	pName := t.Name()

	testTags := opentracing.Tags{
		"span.kind":      "test",
		"test.name":      method.Info.Name,
		"test.suite":     pName,
		"test.framework": "gopkg.in/check.v1",
		"test.language":  "go",
	}

	span, _ := opentracing.StartSpanFromContextWithTracer(context.Background(), instrumentation.Tracer(), method.Info.Name, testTags)
	span.SetBaggageItem("trace.kind", "test")
	span.SetTag("test.status", tags.TestStatus_CACHE)
	span.Finish()
}

// start test func
func startTest(method *methodType, c *chk.C) *Test {
	test := &Test{
		method: method,
		c:      c,
	}

	_, _, testCode := instrumentation.GetPackageAndNameAndBoundaries(test.method.Info.Func.Pointer())
	t := method.Info.Type.In(0)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	pName := t.Name()

	testTags := opentracing.Tags{
		"span.kind":      "test",
		"test.name":      test.method.Info.Name,
		"test.suite":     pName,
		"test.framework": "gopkg.in/check.v1",
		"test.language":  "go",
	}

	if testCode != "" {
		testTags["test.code"] = testCode
	}

	if test.ctx == nil {
		test.ctx = context.Background()
	}

	span, ctx := opentracing.StartSpanFromContextWithTracer(test.ctx, instrumentation.Tracer(), test.method.Info.Name, testTags)
	span.SetBaggageItem("trace.kind", "test")
	test.span = span
	test.ctx = ctx
	coverage.StartCoverage()

	return test
}

// end test func
func (test *Test) end(c *chk.C) {
	finishTime := time.Now()

	// Stop and get records generated by loggers
	logRecords := logging.GetRecords()

	finishOptions := opentracing.FinishOptions{
		FinishTime: finishTime,
		LogRecords: logRecords,
	}

	if testing.CoverMode() != "" {
		if cov := coverage.EndCoverage(); cov != nil {
			test.span.SetTag(tags.Coverage, *cov)
		}
	}

	if r := recover(); r != nil {
		test.span.SetTag("test.status", tags.TestStatus_FAIL)
		errors.WriteExceptionEvent(test.span, r, 1)
		test.span.FinishWithOptions(finishOptions)
		panic(r)
	}

	reason := getTestReason(c)
	status := getTestStatus(c)
	switch status {
	case testSucceeded:
		if !getTestMustFail(c) {
			test.span.SetTag("test.status", tags.TestStatus_PASS)
			reason = ""
		} else {
			test.span.SetTag("test.status", tags.TestStatus_FAIL)
			test.span.SetTag("error", true)
		}
	case testFailed:
		if getTestMustFail(c) {
			test.span.SetTag("test.status", tags.TestStatus_PASS)
			reason = ""
		} else {
			test.span.SetTag("test.status", tags.TestStatus_FAIL)
			test.span.SetTag("error", true)
			if reason == "" {
				reason = "Test failed"
			}
		}
	case testSkipped:
		test.span.SetTag("test.status", tags.TestStatus_SKIP)
	case testPanicked, testFixturePanicked:
		test.span.SetTag("test.status", tags.TestStatus_FAIL)
		test.span.SetTag("error", true)
	case testMissed:
		test.span.SetTag("test.status", tags.TestStatus_SKIP)
	default:
		test.span.SetTag("test.status", status)
		test.span.SetTag("error", true)
	}

	if reason != "" {
		eventType := tags.EventTestFailure
		if status == testSkipped {
			eventType = tags.EventTestSkip
		}
		test.span.LogFields(
			log.String(tags.EventType, eventType),
			log.String(tags.EventMessage, reason),
			log.String("log.internal_level", "Fatal"),
			log.String("log.logger", "testing"),
		)
	}

	test.span.FinishWithOptions(finishOptions)
}

// write the benchmark result
func writeBenchmarkResult(method *methodType, c *chk.C, tm timer) {
	t := method.Info.Type.In(0)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	pName := t.Name()

	opts := []opentracing.StartSpanOption{
		opentracing.Tags{
			"span.kind":      "test",
			"test.name":      method.Info.Name,
			"test.suite":     pName,
			"test.framework": "gopkg.in/check.v1",
			"test.language":  "go",
			"test.type":      "benchmark",
		},
		opentracing.StartTime(tm.start),
	}

	span, _ := opentracing.StartSpanFromContextWithTracer(context.Background(), instrumentation.Tracer(), method.Info.Name, opts...)
	span.SetBaggageItem("trace.kind", "test")
	avg := math.Round((float64(tm.duration.Nanoseconds())/float64(c.N))*100) / 100
	meanAllocsPerOp := math.Round((float64(tm.netAllocs)/float64(c.N))*100) / 100
	meanAllocedBytesPerOp := math.Round((float64(tm.netBytes)/float64(c.N))*100) / 100

	span.SetTag("benchmark.runs", c.N)
	span.SetTag("benchmark.duration.mean", avg)
	span.SetTag("benchmark.memory.mean_allocations", meanAllocsPerOp)
	span.SetTag("benchmark.memory.mean_bytes_allocations", meanAllocedBytesPerOp)

	reason := getTestReason(c)
	status := getTestStatus(c)
	switch status {
	case testSucceeded:
		if !getTestMustFail(c) {
			span.SetTag("test.status", tags.TestStatus_PASS)
			reason = ""
		} else {
			span.SetTag("test.status", tags.TestStatus_FAIL)
			span.SetTag("error", true)
		}
	case testFailed:
		if getTestMustFail(c) {
			span.SetTag("test.status", tags.TestStatus_PASS)
			reason = ""
		} else {
			span.SetTag("test.status", tags.TestStatus_FAIL)
			span.SetTag("error", true)
			if reason == "" {
				reason = "Test failed"
			}
		}
	case testSkipped:
		span.SetTag("test.status", tags.TestStatus_SKIP)
	case testPanicked, testFixturePanicked:
		span.SetTag("test.status", tags.TestStatus_FAIL)
		span.SetTag("error", true)
	case testMissed:
		span.SetTag("test.status", tags.TestStatus_SKIP)
	default:
		span.SetTag("test.status", status)
		span.SetTag("error", true)
	}

	if reason != "" {
		eventType := tags.EventTestFailure
		if status == testSkipped {
			eventType = tags.EventTestSkip
		}
		span.LogFields(
			log.String(tags.EventType, eventType),
			log.String(tags.EventMessage, reason),
			log.String("log.internal_level", "Fatal"),
			log.String("log.logger", "testing"),
		)
	}

	span.FinishWithOptions(opentracing.FinishOptions{
		FinishTime: tm.start.Add(tm.duration),
	})
}
